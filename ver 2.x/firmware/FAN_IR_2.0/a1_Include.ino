/*** БИБЛИОТЕКИ ***/
#include <TimerMs.h>     // Многофункциональный программный таймер на системном таймере millis() "https://github.com/GyverLibs/TimerMs" [используется ver. 1.2]
#include <SoftServo.h>   // Библиотека для программного управления Servo (на базе millis/micros) "https://github.com/GyverLibs/SoftServo" [используется ver. 1.2]
#include <NecDecoder.h>  // Лёгкая библиотека для декодирования ИК протокола NEC "https://github.com/GyverLibs/NecDecoder" [используется ver. 2.1]
#include <EEPROM.h>      // Библиотека для работы с энергонезависимой памятью EEPROM [входит в состав ядра MiniCore]


// Вкл. или Откл. WatchDog при компиляции (выбираем сами на вкладке "a0_Settings")
#if (WDT_ENABLE == 1)
#include <avr/wdt.h>
#endif

/*** ОБЪЕКТЫ ***/
SoftServo rotation;  // Создаём Объект для Sertvo
NecDecoder ir;       // Создаём Объект для ИК приёмника



// (период, мс), (0 не запущен / 1 запущен), (режим: 0 период / 1 таймер)
TimerMs mode1(TIMER_MODE1, 0, 1);  // Таймер 1 на все 4 режима
TimerMs mode2(TIMER_MODE2, 0, 1);  // Таймер 2 на все 4 режима



/*** ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ***/

//Управление пинами МК
const byte Relay_Array[4] = { RELAY1, RELAY2, RELAY3, RELAY4 };  // Массив реле
const byte Led_Array[3] = { LED_GREAN, LED_BLUE, LED_RED };      // Массив LED

//Для кольцевого буфера
bool flagWR = false;  // Если "true", то выполняем запись в EEPROM (срабатывает только 1 раз, когда EEPROM полностью чиста)
int addr;             // Адрес памяти в EEPROM, откуда будем считывать и куда записывать значения наших данных
byte eePos;           // Считываем сюда и пишем отсюда данные из/в EEPROM


//Отложеная запись в EEPROM по таймеру (защита от частой перезаписи при долгом удержании кнопок: < Влево или Вправо >)
uint32_t ee_tmr = 0;   // Таймер задержки обновления для отложенной записи положения Servo в EEPROM
bool ee_flag = false;  // Флаг разрешающий отложенную проверку и запуск сохранения в EEPROM по таймеру


//Автоповороты Servo
int servo_val;                 // Положение Серво
int dir = AUTO_DIR_ITERATION;  // Градус поворота для каждой итерации функции
bool auto_RotatON = false;     // Если "true", то включаем автоповороты Servo
uint32_t tmr_auto = 0;         // Последнее обновление времени (для автоповоротов Servo)


//Ручные повороты Servo
int counter = COUNT_DIR_ITERATION;  // Увеличиваем или уменьшаем перемещение на каждом шаге для ручных поворотов
bool RotatON = false;               // Если "true", то включаем повороты Servo(влево - вправо)
bool Right_Turns = false;           // Если "true", то поворачиваем вручную Servo вправо (при зажатии кнопки вправо)
bool Left_Turns = false;            // Если "true", то поворачиваем вручную Servo влево (при зажатии кнопки влево)


//Массив флагов для защиты от быстрого откл./вкл. (перещёлкивания) реле при повторном приёме ИК сигнала и в пределах одного режима
//Первый элемент массива "нулевой" используется для флага задержки "DELAY_REL_OFF" между переключениями реле, остальные флаги для переключения смены режимов
bool repeat[] = { 0, 0, 0, 0, 0 };  // Объявляем массив без явного задания размера. Порядковый номер флага равняется номеру реле { задержка, Реле1, Реле2, Реле1, Реле4 }
